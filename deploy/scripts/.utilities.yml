# Subroutines for deployment

# Set standard vars and generate version tag for build
# Standard vault policies: [default, jwt, read-tokens, read-apps, read-ssl-certificates]
# Tag format:
#   - image format: "1.5.3"
#   - GitLab release format: "v1.5.3"
#   - app format (feature/main branch): "v1.5.3-c7754fc6"
#   - app format (release branch): "v1.5.3"
.init:                            
  image: alpine/git:latest
  script:
    - echo "VERSION_TAG=$(git describe --tags $(git rev-list --tags --max-count=1) | cut -c 2-)-$CI_COMMIT_SHORT_SHA" | tee build.env
  artifacts:
    reports:
      dotenv: build.env
  tags:
    - production


# Configure cluster ENVs
#   - vars defined here are not available for GitLab `environment` definitions
#   - currently limited to:
#       - "dev-cp"
#       - "dev-vsm"
# Secret names correspond to certificate SAN's (eg. star-dev-ltc-bcit-ca protects `*.dev.ltc.bcit.ca`)
.get_env:
  script:
    - |
      if [ "$BUILD_ENV" == "dev" ] && [ $CLUSTER_ENV == "dev-cp" ]
      then
          CI_HOST="$DEV_HOST"
          NAMESPACE_NAME="$CI_COMMIT_REF_SLUG"
          CLUSTER_ID="$RANCHER_DEV_CP_CLUSTER_ID"
          PROJECT_ID="$RANCHER_DEV_CP_DEFAULT_PROJECT_ID"
      elif [ "$BUILD_ENV" == "dev" ] && [ $CLUSTER_ENV == "dev-vsm" ]
      then
          CI_HOST="$DEV_HOST"
          NAMESPACE_NAME="$CI_COMMIT_REF_SLUG"
          CLUSTER_ID="$RANCHER_DEV_VSM_CLUSTER_ID"
          PROJECT_ID="$RANCHER_DEV_VSM_DEFAULT_PROJECT_ID"
      elif [ "$BUILD_ENV" == "staging" ]
      then
          CI_HOST="$STAGING_HOST"
          NAMESPACE_NAME="$CI_PROJECT_NAME"
          CLUSTER_ID="$RANCHER_STAGING_CLUSTER_ID"
          PROJECT_ID="$RANCHER_STAGING_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="star-dev-ltc-bcit-ca"
      elif [ "$BUILD_ENV" == "prod" ]
      then
          CI_HOST="$PROD_HOST"
          NAMESPACE_NAME="$CI_PROJECT_NAME"
          CLUSTER_ID="$RANCHER_PROD_CLUSTER_ID"
          PROJECT_ID="$RANCHER_PROD_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="star-dev-ltc-bcit-ca"
          VERSION_TAG="$(echo $CI_COMMIT_TAG | cut -c 2-)"
      else
          echo "\"$BUILD_ENV\" is not set correctly"
          exit 1
      fi

      echo -e "Environment variables: \
        \n  CI_HOST: $CI_HOST \
        \n  NAMESPACE_NAME: $NAMESPACE_NAME \
        \n  CLUSTER_ID: $CLUSTER_ID \
        \n  PROJECT_ID: $PROJECT_ID \
        \n  TLS_SECRET_NAME: $TLS_SECRET_NAME \
        \n  VERSION_TAG: $VERSION_TAG \
        \n"


# Creates a namespace annotation to ensure it's visible in the Rancher Default project
# TODO: find a better way to update namespace (duplicates exist with this code)
.annotate_namespace:
  script:
    - |
      if [ -n "$PROD_NAMESPACE" ] && ( [ "$BUILD_ENV" == "staging" ] || [ "$BUILD_ENV" == "prod" ] )
      then
          NAMESPACE_NAME="$PROD_NAMESPACE"
          echo -e " \
          \nnamespace: $NAMESPACE_NAME" >> deploy/overlays/$BUILD_ENV/kustomization.yaml

          echo -e "\nPROD_NAMESPACE detected. Setting NAMESPACE_NAME to $NAMESPACE_NAME"
      else
          echo -e " \
            \nnamespace: $NAMESPACE_NAME" >> deploy/overlays/$BUILD_ENV/kustomization.yaml
      fi

      echo -e "[ \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/field.cattle.io~1projectId\", \"value\": \"$CLUSTER_ID\:$PROJECT_ID\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/labels/field.cattle.io~1projectId\", \"value\": \"$PROJECT_ID\"}, \
        \n]" > deploy/overlays/$BUILD_ENV/namespace-patch.json

      echo -e " \
        \npatches: \
        \n  - target: \
        \n      kind: Namespace \
        \n      name: $NAMESPACE_NAME \
        \n    path: namespace-patch.json" >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e "\nNamespace patch added to kustomization"


# Creates deployment annotations that mirror image labels that can be injected into the kubernetes resource
# Please note:
#   - `path_name` and `cluster_name` are only added as annotations to the kubernetes resource
#   - `title` and `description` are only added as labels to the image
.annotate_deployment:
  script:
    - |
      echo -e "[ \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/version\", \"value\": \"$VERSION_TAG\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/build_hash\", \"value\": \"$CI_COMMIT_SHA\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/build_short_sha\", \"value\": \"$CI_COMMIT_SHORT_SHA\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/build_timestamp\", \"value\": \"$CI_PIPELINE_CREATED_AT\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/build_env\", \"value\": \"$BUILD_ENV\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/path_name\", \"value\": \"$NAMESPACE_NAME\"}, \
        \n  {\"op\": \"add\", \"path\": \"/metadata/annotations/cluster_name\", \"value\": \"$CLUSTER_ENV\"} \
        \n]" > deploy/overlays/$BUILD_ENV/deployment-patch.json

      echo -e "\nDeployment json patch info: \
        \n \
        \n  version: $VERSION_TAG \
        \n  build_hash: $CI_COMMIT_SHA \
        \n  build_short_sha: $CI_COMMIT_SHORT_SHA \
        \n  build_timestamp: $CI_PIPELINE_CREATED_AT \
        \n  build_env: $BUILD_ENV \
        \n  path_name: $NAMESPACE_NAME \
        \n  cluster_name: $BUILD_ENV \
        \n"

      echo -e " \
        \npatches: \
        \n  - target: \
        \n      kind: Deployment \
        \n      name: $CI_PROJECT_NAME \
        \n      namespace: $NAMESPACE_NAME \
        \n    path: deployment-patch.json" >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e "\nDeployment patch added to kustomization"


# Patches existing `deployment.yaml` to be applied to kustomization
# to add volume mounts to inject annotations and labels to the deployment
# .patch_deployment_dev:
#   script:
#     - |
#       echo -e " \
#         \napiVersion: apps/v1 \
#         \nkind: Deployment \
#         \nmetadata: \
#         \n  name: $CI_PROJECT_NAME \
#         \n  namespace: $NAMESPACE_NAME \
#         \n  labels: \
#         \n    app: $CI_PROJECT_NAME \
#         \nspec: \
#         \n  template: \
#         \n    spec: \
#         \n      containers: \
#         \n      - name: $CI_PROJECT_NAME \
#         \n        image: $CI_PROJECT_NAME \
#         \n        volumeMounts: \
#         \n          - name: podinfo \
#         \n            mountPath: /etc/podinfo \
#         \n      volumes: \
#         \n        - name: podinfo \
#         \n          downwardAPI: \
#         \n            items: \
#         \n              - path: "labels" \
#         \n                fieldRef: \
#         \n                  fieldPath: metadata.labels \
#         \n              - path: "annotations" \
#         \n                fieldRef: \
#         \n                  fieldPath: metadata.annotations" > deploy/overlays/$CI_ENV/deployment.yaml

#       echo -e " \
#         \nDev deployment patched"


# add kustomizations to pull latest commit image for dev/staging
.kustomize_image:
  script:
    - |
      if [ "$BUILD_ENV" == "prod" ]
      then
          DEPLOY_TAG="$CI_COMMIT_TAG"
      else
          DEPLOY_TAG="$CI_COMMIT_SHORT_SHA"
      fi

      echo -e "\nDeploy tag set to: $DEPLOY_TAG"

      echo -e " \
        \nimages: \
        \n  - name: $CI_PROJECT_NAME \
        \n    newName: $CI_REGISTRY_IMAGE \
        \n    newTag: \"$DEPLOY_TAG\"" >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e "\nImage patch added to kustomization"


# add annotations that link a deployment to GitLab's Environment/Operations dashboards
.add_common_annotations:
  script:
    - |
      echo -e " \
        \ncommonAnnotations: \
        \n  app.gitlab.com/app: $CI_PROJECT_PATH_SLUG \
        \n  app.gitlab.com/env: $CI_ENVIRONMENT_SLUG" >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e " \
        \nCommon annotations added to kustomization"


# Patches existing `ingress.yaml` to be applied to kustomization
# target URL:
#   - https://{CI_PROJECT_NAME}.{CLUSTER_ENV}.reviews.dev.ltc.bcit.ca/{CI_COMMIT_REF_SLUG}
#     eg. https://qcon-api.dev-cp.reviews.dev.ltc.bcit.ca/189-fix-tls
.patch_ingress_dev:
  script:
    - |
      echo -e " \
        \napiVersion: networking.k8s.io/v1 \
        \nkind: Ingress \
        \nmetadata: \
        \n  name: $CI_PROJECT_NAME-ingress \
        \n  namespace: $NAMESPACE_NAME \
        \n  annotations: \
        \n    nginx.ingress.kubernetes.io/rewrite-target: /\$2 \
        \n    nginx.ingress.kubernetes.io/configuration-snippet: rewrite ($NAMESPACE_NAME)$ $NAMESPACE_NAME/ redirect; \
        \nspec: \
        \n  rules: \
        \n  - host: $CI_PROJECT_NAME.$CLUSTER_ENV.$CI_HOST \
        \n    http: \
        \n      paths: \
        \n      - path: /$NAMESPACE_NAME \
        \n        pathType: Prefix \
        \n        backend: \
        \n          service: \
        \n            name: $CI_PROJECT_NAME-service \
        \n            port: \
        \n              number: $APP_PORT" > deploy/overlays/$BUILD_ENV/ingress.yaml

      echo -e " \
        \nIngress-dev resource replaced with kustomization"


# STAGING target URL: 
  # - https://latest.dev.ltc.bcit.ca/{CI_PROJECT_NAME}
  #   eg. https://latest.dev.ltc.bcit.ca/qcon-api

# PROD target URLs:
# Default
  # - https://stable.dev.ltc.bcit.ca/{CI_PROJECT_NAME}
  #   eg. https://stable.dev.ltc.bcit.ca/qcon-api
# Extra
  # - https://{PROD_NAMESPACE}.ltc.bcit.ca/
  #   eg. https://qcon-api.ltc.bcit.ca
.patch_ingress:
  script:
    - |
      echo -e " \
        \napiVersion: networking.k8s.io/v1 \
        \nkind: Ingress \
        \nmetadata: \
        \n  name: $CI_PROJECT_NAME-ingress \
        \n  namespace: $NAMESPACE_NAME \
        \n  annotations: \
        \n    nginx.ingress.kubernetes.io/rewrite-target: /\$2 \
        \n    nginx.ingress.kubernetes.io/configuration-snippet: rewrite ($CI_PROJECT_NAME)$ $CI_PROJECT_NAME/ redirect; \
        \nspec: \
        \n  tls: \
        \n  - hosts: \
        \n    - $CI_HOST \
        \n    secretName: $TLS_SECRET_NAME \
        \n  rules: \
        \n  - host: $CI_HOST \
        \n    http: \
        \n      paths: \
        \n      - path: /$CI_PROJECT_NAME \
        \n        pathType: Prefix \
        \n        backend: \
        \n          service: \
        \n            name: $CI_PROJECT_NAME-service \
        \n            port: \
        \n              number: $APP_PORT" > deploy/overlays/$BUILD_ENV/ingress.yaml

      echo -e " \
        \nIngress resource replaced with kustomization"


# create tls secret for ingress via Kustomize secretGenerator spec
.create_tls_secret:
  script:
    - |
      echo "$TLS_CRT" | base64 --decode > deploy/overlays/$BUILD_ENV/tls.crt
      echo "$TLS_KEY" | base64 --decode > deploy/overlays/$BUILD_ENV/tls.key

      echo -e " \
        \nData files for TLS secret generation created successfully"


# validate kustomizations that have been patched are syntactictally correct
.verify_kustomization:
  script:
    - |
      echo -e " \
        \n##### Kustomization being applied:\n"

      cat deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e " \
        \n##### Kustomized resources being applied to cluster:\n"

      kubectl kustomize deploy/overlays/$BUILD_ENV


# Common Tags and Rules for jobs
.feature_branch_rules:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "release"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS'
  tags:
    - $CLUSTER_ENV

.main_branch_rules:
  rules:
    - if: '$CI_COMMIT_REF_SLUG == "main" && $CI_PIPELINE_SOURCE == "push"'
  tags:
    - staging

.semver_tag_rules:
  rules:
    - if: '$CI_COMMIT_REF_SLUG == "release" && $CI_PIPELINE_SOURCE == "push"'
  tags:
    - production

.release_branch_rules:
  rules:
    - if: $CI_COMMIT_TAG
  tags:
    - production